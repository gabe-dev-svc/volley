// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/gabe-dev-svc/volley/internal/repository"
	"github.com/jackc/pgx/v5/pgtype"
	mock "github.com/stretchr/testify/mock"
)

// NewQuerier creates a new instance of Querier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *Querier {
	mock := &Querier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// Querier is an autogenerated mock type for the Querier type
type Querier struct {
	mock.Mock
}

type Querier_Expecter struct {
	mock *mock.Mock
}

func (_m *Querier) EXPECT() *Querier_Expecter {
	return &Querier_Expecter{mock: &_m.Mock}
}

// BatchUpdateParticipantsToConfirmed provides a mock function for the type Querier
func (_mock *Querier) BatchUpdateParticipantsToConfirmed(ctx context.Context, participantIds []pgtype.UUID) error {
	ret := _mock.Called(ctx, participantIds)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdateParticipantsToConfirmed")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []pgtype.UUID) error); ok {
		r0 = returnFunc(ctx, participantIds)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Querier_BatchUpdateParticipantsToConfirmed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchUpdateParticipantsToConfirmed'
type Querier_BatchUpdateParticipantsToConfirmed_Call struct {
	*mock.Call
}

// BatchUpdateParticipantsToConfirmed is a helper method to define mock.On call
//   - ctx context.Context
//   - participantIds []pgtype.UUID
func (_e *Querier_Expecter) BatchUpdateParticipantsToConfirmed(ctx interface{}, participantIds interface{}) *Querier_BatchUpdateParticipantsToConfirmed_Call {
	return &Querier_BatchUpdateParticipantsToConfirmed_Call{Call: _e.mock.On("BatchUpdateParticipantsToConfirmed", ctx, participantIds)}
}

func (_c *Querier_BatchUpdateParticipantsToConfirmed_Call) Run(run func(ctx context.Context, participantIds []pgtype.UUID)) *Querier_BatchUpdateParticipantsToConfirmed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].([]pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_BatchUpdateParticipantsToConfirmed_Call) Return(err error) *Querier_BatchUpdateParticipantsToConfirmed_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Querier_BatchUpdateParticipantsToConfirmed_Call) RunAndReturn(run func(ctx context.Context, participantIds []pgtype.UUID) error) *Querier_BatchUpdateParticipantsToConfirmed_Call {
	_c.Call.Return(run)
	return _c
}

// BatchUpdateParticipantsToWaitlist provides a mock function for the type Querier
func (_mock *Querier) BatchUpdateParticipantsToWaitlist(ctx context.Context, participantIds []pgtype.UUID) error {
	ret := _mock.Called(ctx, participantIds)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdateParticipantsToWaitlist")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []pgtype.UUID) error); ok {
		r0 = returnFunc(ctx, participantIds)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Querier_BatchUpdateParticipantsToWaitlist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchUpdateParticipantsToWaitlist'
type Querier_BatchUpdateParticipantsToWaitlist_Call struct {
	*mock.Call
}

// BatchUpdateParticipantsToWaitlist is a helper method to define mock.On call
//   - ctx context.Context
//   - participantIds []pgtype.UUID
func (_e *Querier_Expecter) BatchUpdateParticipantsToWaitlist(ctx interface{}, participantIds interface{}) *Querier_BatchUpdateParticipantsToWaitlist_Call {
	return &Querier_BatchUpdateParticipantsToWaitlist_Call{Call: _e.mock.On("BatchUpdateParticipantsToWaitlist", ctx, participantIds)}
}

func (_c *Querier_BatchUpdateParticipantsToWaitlist_Call) Run(run func(ctx context.Context, participantIds []pgtype.UUID)) *Querier_BatchUpdateParticipantsToWaitlist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].([]pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_BatchUpdateParticipantsToWaitlist_Call) Return(err error) *Querier_BatchUpdateParticipantsToWaitlist_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Querier_BatchUpdateParticipantsToWaitlist_Call) RunAndReturn(run func(ctx context.Context, participantIds []pgtype.UUID) error) *Querier_BatchUpdateParticipantsToWaitlist_Call {
	_c.Call.Return(run)
	return _c
}

// CancelGame provides a mock function for the type Querier
func (_mock *Querier) CancelGame(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for CancelGame")
	}

	var r0 pgtype.UUID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) (pgtype.UUID, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) pgtype.UUID); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(pgtype.UUID)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_CancelGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelGame'
type Querier_CancelGame_Call struct {
	*mock.Call
}

// CancelGame is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) CancelGame(ctx interface{}, id interface{}) *Querier_CancelGame_Call {
	return &Querier_CancelGame_Call{Call: _e.mock.On("CancelGame", ctx, id)}
}

func (_c *Querier_CancelGame_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_CancelGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_CancelGame_Call) Return(uUID pgtype.UUID, err error) *Querier_CancelGame_Call {
	_c.Call.Return(uUID, err)
	return _c
}

func (_c *Querier_CancelGame_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error)) *Querier_CancelGame_Call {
	_c.Call.Return(run)
	return _c
}

// CountConfirmedParticipants provides a mock function for the type Querier
func (_mock *Querier) CountConfirmedParticipants(ctx context.Context, gameID pgtype.UUID) (int64, error) {
	ret := _mock.Called(ctx, gameID)

	if len(ret) == 0 {
		panic("no return value specified for CountConfirmedParticipants")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) (int64, error)); ok {
		return returnFunc(ctx, gameID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) int64); ok {
		r0 = returnFunc(ctx, gameID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, gameID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_CountConfirmedParticipants_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountConfirmedParticipants'
type Querier_CountConfirmedParticipants_Call struct {
	*mock.Call
}

// CountConfirmedParticipants is a helper method to define mock.On call
//   - ctx context.Context
//   - gameID pgtype.UUID
func (_e *Querier_Expecter) CountConfirmedParticipants(ctx interface{}, gameID interface{}) *Querier_CountConfirmedParticipants_Call {
	return &Querier_CountConfirmedParticipants_Call{Call: _e.mock.On("CountConfirmedParticipants", ctx, gameID)}
}

func (_c *Querier_CountConfirmedParticipants_Call) Run(run func(ctx context.Context, gameID pgtype.UUID)) *Querier_CountConfirmedParticipants_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_CountConfirmedParticipants_Call) Return(n int64, err error) *Querier_CountConfirmedParticipants_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *Querier_CountConfirmedParticipants_Call) RunAndReturn(run func(ctx context.Context, gameID pgtype.UUID) (int64, error)) *Querier_CountConfirmedParticipants_Call {
	_c.Call.Return(run)
	return _c
}

// CountWaitlistParticipants provides a mock function for the type Querier
func (_mock *Querier) CountWaitlistParticipants(ctx context.Context, gameID pgtype.UUID) (int64, error) {
	ret := _mock.Called(ctx, gameID)

	if len(ret) == 0 {
		panic("no return value specified for CountWaitlistParticipants")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) (int64, error)); ok {
		return returnFunc(ctx, gameID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) int64); ok {
		r0 = returnFunc(ctx, gameID)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, gameID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_CountWaitlistParticipants_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountWaitlistParticipants'
type Querier_CountWaitlistParticipants_Call struct {
	*mock.Call
}

// CountWaitlistParticipants is a helper method to define mock.On call
//   - ctx context.Context
//   - gameID pgtype.UUID
func (_e *Querier_Expecter) CountWaitlistParticipants(ctx interface{}, gameID interface{}) *Querier_CountWaitlistParticipants_Call {
	return &Querier_CountWaitlistParticipants_Call{Call: _e.mock.On("CountWaitlistParticipants", ctx, gameID)}
}

func (_c *Querier_CountWaitlistParticipants_Call) Run(run func(ctx context.Context, gameID pgtype.UUID)) *Querier_CountWaitlistParticipants_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_CountWaitlistParticipants_Call) Return(n int64, err error) *Querier_CountWaitlistParticipants_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *Querier_CountWaitlistParticipants_Call) RunAndReturn(run func(ctx context.Context, gameID pgtype.UUID) (int64, error)) *Querier_CountWaitlistParticipants_Call {
	_c.Call.Return(run)
	return _c
}

// CreateGame provides a mock function for the type Querier
func (_mock *Querier) CreateGame(ctx context.Context, arg repository.CreateGameParams) (repository.CreateGameRow, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateGame")
	}

	var r0 repository.CreateGameRow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.CreateGameParams) (repository.CreateGameRow, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.CreateGameParams) repository.CreateGameRow); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.CreateGameRow)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.CreateGameParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_CreateGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateGame'
type Querier_CreateGame_Call struct {
	*mock.Call
}

// CreateGame is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.CreateGameParams
func (_e *Querier_Expecter) CreateGame(ctx interface{}, arg interface{}) *Querier_CreateGame_Call {
	return &Querier_CreateGame_Call{Call: _e.mock.On("CreateGame", ctx, arg)}
}

func (_c *Querier_CreateGame_Call) Run(run func(ctx context.Context, arg repository.CreateGameParams)) *Querier_CreateGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.CreateGameParams
		if args[1] != nil {
			arg1 = args[1].(repository.CreateGameParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_CreateGame_Call) Return(createGameRow repository.CreateGameRow, err error) *Querier_CreateGame_Call {
	_c.Call.Return(createGameRow, err)
	return _c
}

func (_c *Querier_CreateGame_Call) RunAndReturn(run func(ctx context.Context, arg repository.CreateGameParams) (repository.CreateGameRow, error)) *Querier_CreateGame_Call {
	_c.Call.Return(run)
	return _c
}

// CreateParticipant provides a mock function for the type Querier
func (_mock *Querier) CreateParticipant(ctx context.Context, arg repository.CreateParticipantParams) (repository.Participant, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateParticipant")
	}

	var r0 repository.Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.CreateParticipantParams) (repository.Participant, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.CreateParticipantParams) repository.Participant); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.Participant)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.CreateParticipantParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_CreateParticipant_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateParticipant'
type Querier_CreateParticipant_Call struct {
	*mock.Call
}

// CreateParticipant is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.CreateParticipantParams
func (_e *Querier_Expecter) CreateParticipant(ctx interface{}, arg interface{}) *Querier_CreateParticipant_Call {
	return &Querier_CreateParticipant_Call{Call: _e.mock.On("CreateParticipant", ctx, arg)}
}

func (_c *Querier_CreateParticipant_Call) Run(run func(ctx context.Context, arg repository.CreateParticipantParams)) *Querier_CreateParticipant_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.CreateParticipantParams
		if args[1] != nil {
			arg1 = args[1].(repository.CreateParticipantParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_CreateParticipant_Call) Return(participant repository.Participant, err error) *Querier_CreateParticipant_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *Querier_CreateParticipant_Call) RunAndReturn(run func(ctx context.Context, arg repository.CreateParticipantParams) (repository.Participant, error)) *Querier_CreateParticipant_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTeam provides a mock function for the type Querier
func (_mock *Querier) CreateTeam(ctx context.Context, arg repository.CreateTeamParams) (repository.Team, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateTeam")
	}

	var r0 repository.Team
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.CreateTeamParams) (repository.Team, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.CreateTeamParams) repository.Team); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.Team)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.CreateTeamParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_CreateTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTeam'
type Querier_CreateTeam_Call struct {
	*mock.Call
}

// CreateTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.CreateTeamParams
func (_e *Querier_Expecter) CreateTeam(ctx interface{}, arg interface{}) *Querier_CreateTeam_Call {
	return &Querier_CreateTeam_Call{Call: _e.mock.On("CreateTeam", ctx, arg)}
}

func (_c *Querier_CreateTeam_Call) Run(run func(ctx context.Context, arg repository.CreateTeamParams)) *Querier_CreateTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.CreateTeamParams
		if args[1] != nil {
			arg1 = args[1].(repository.CreateTeamParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_CreateTeam_Call) Return(team repository.Team, err error) *Querier_CreateTeam_Call {
	_c.Call.Return(team, err)
	return _c
}

func (_c *Querier_CreateTeam_Call) RunAndReturn(run func(ctx context.Context, arg repository.CreateTeamParams) (repository.Team, error)) *Querier_CreateTeam_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function for the type Querier
func (_mock *Querier) CreateUser(ctx context.Context, arg repository.CreateUserParams) (repository.User, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 repository.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.CreateUserParams) (repository.User, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.CreateUserParams) repository.User); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.CreateUserParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type Querier_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.CreateUserParams
func (_e *Querier_Expecter) CreateUser(ctx interface{}, arg interface{}) *Querier_CreateUser_Call {
	return &Querier_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, arg)}
}

func (_c *Querier_CreateUser_Call) Run(run func(ctx context.Context, arg repository.CreateUserParams)) *Querier_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.CreateUserParams
		if args[1] != nil {
			arg1 = args[1].(repository.CreateUserParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_CreateUser_Call) Return(user repository.User, err error) *Querier_CreateUser_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *Querier_CreateUser_Call) RunAndReturn(run func(ctx context.Context, arg repository.CreateUserParams) (repository.User, error)) *Querier_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGame provides a mock function for the type Querier
func (_mock *Querier) DeleteGame(ctx context.Context, id pgtype.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGame")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Querier_DeleteGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGame'
type Querier_DeleteGame_Call struct {
	*mock.Call
}

// DeleteGame is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) DeleteGame(ctx interface{}, id interface{}) *Querier_DeleteGame_Call {
	return &Querier_DeleteGame_Call{Call: _e.mock.On("DeleteGame", ctx, id)}
}

func (_c *Querier_DeleteGame_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_DeleteGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_DeleteGame_Call) Return(err error) *Querier_DeleteGame_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Querier_DeleteGame_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) error) *Querier_DeleteGame_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteParticipant provides a mock function for the type Querier
func (_mock *Querier) DeleteParticipant(ctx context.Context, id pgtype.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteParticipant")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Querier_DeleteParticipant_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteParticipant'
type Querier_DeleteParticipant_Call struct {
	*mock.Call
}

// DeleteParticipant is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) DeleteParticipant(ctx interface{}, id interface{}) *Querier_DeleteParticipant_Call {
	return &Querier_DeleteParticipant_Call{Call: _e.mock.On("DeleteParticipant", ctx, id)}
}

func (_c *Querier_DeleteParticipant_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_DeleteParticipant_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_DeleteParticipant_Call) Return(err error) *Querier_DeleteParticipant_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Querier_DeleteParticipant_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) error) *Querier_DeleteParticipant_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTeam provides a mock function for the type Querier
func (_mock *Querier) DeleteTeam(ctx context.Context, id pgtype.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTeam")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Querier_DeleteTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTeam'
type Querier_DeleteTeam_Call struct {
	*mock.Call
}

// DeleteTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) DeleteTeam(ctx interface{}, id interface{}) *Querier_DeleteTeam_Call {
	return &Querier_DeleteTeam_Call{Call: _e.mock.On("DeleteTeam", ctx, id)}
}

func (_c *Querier_DeleteTeam_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_DeleteTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_DeleteTeam_Call) Return(err error) *Querier_DeleteTeam_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Querier_DeleteTeam_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) error) *Querier_DeleteTeam_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function for the type Querier
func (_mock *Querier) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Querier_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type Querier_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) DeleteUser(ctx interface{}, id interface{}) *Querier_DeleteUser_Call {
	return &Querier_DeleteUser_Call{Call: _e.mock.On("DeleteUser", ctx, id)}
}

func (_c *Querier_DeleteUser_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_DeleteUser_Call) Return(err error) *Querier_DeleteUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *Querier_DeleteUser_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) error) *Querier_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetGame provides a mock function for the type Querier
func (_mock *Querier) GetGame(ctx context.Context, id pgtype.UUID) (repository.GetGameRow, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetGame")
	}

	var r0 repository.GetGameRow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) (repository.GetGameRow, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) repository.GetGameRow); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(repository.GetGameRow)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_GetGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGame'
type Querier_GetGame_Call struct {
	*mock.Call
}

// GetGame is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) GetGame(ctx interface{}, id interface{}) *Querier_GetGame_Call {
	return &Querier_GetGame_Call{Call: _e.mock.On("GetGame", ctx, id)}
}

func (_c *Querier_GetGame_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_GetGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_GetGame_Call) Return(getGameRow repository.GetGameRow, err error) *Querier_GetGame_Call {
	_c.Call.Return(getGameRow, err)
	return _c
}

func (_c *Querier_GetGame_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) (repository.GetGameRow, error)) *Querier_GetGame_Call {
	_c.Call.Return(run)
	return _c
}

// GetGameForUpdate provides a mock function for the type Querier
func (_mock *Querier) GetGameForUpdate(ctx context.Context, id pgtype.UUID) (repository.GetGameForUpdateRow, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetGameForUpdate")
	}

	var r0 repository.GetGameForUpdateRow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) (repository.GetGameForUpdateRow, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) repository.GetGameForUpdateRow); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(repository.GetGameForUpdateRow)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_GetGameForUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGameForUpdate'
type Querier_GetGameForUpdate_Call struct {
	*mock.Call
}

// GetGameForUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) GetGameForUpdate(ctx interface{}, id interface{}) *Querier_GetGameForUpdate_Call {
	return &Querier_GetGameForUpdate_Call{Call: _e.mock.On("GetGameForUpdate", ctx, id)}
}

func (_c *Querier_GetGameForUpdate_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_GetGameForUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_GetGameForUpdate_Call) Return(getGameForUpdateRow repository.GetGameForUpdateRow, err error) *Querier_GetGameForUpdate_Call {
	_c.Call.Return(getGameForUpdateRow, err)
	return _c
}

func (_c *Querier_GetGameForUpdate_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) (repository.GetGameForUpdateRow, error)) *Querier_GetGameForUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// GetParticipant provides a mock function for the type Querier
func (_mock *Querier) GetParticipant(ctx context.Context, id pgtype.UUID) (repository.Participant, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetParticipant")
	}

	var r0 repository.Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) (repository.Participant, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) repository.Participant); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(repository.Participant)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_GetParticipant_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetParticipant'
type Querier_GetParticipant_Call struct {
	*mock.Call
}

// GetParticipant is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) GetParticipant(ctx interface{}, id interface{}) *Querier_GetParticipant_Call {
	return &Querier_GetParticipant_Call{Call: _e.mock.On("GetParticipant", ctx, id)}
}

func (_c *Querier_GetParticipant_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_GetParticipant_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_GetParticipant_Call) Return(participant repository.Participant, err error) *Querier_GetParticipant_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *Querier_GetParticipant_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) (repository.Participant, error)) *Querier_GetParticipant_Call {
	_c.Call.Return(run)
	return _c
}

// GetParticipantByGameAndUser provides a mock function for the type Querier
func (_mock *Querier) GetParticipantByGameAndUser(ctx context.Context, arg repository.GetParticipantByGameAndUserParams) (repository.Participant, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for GetParticipantByGameAndUser")
	}

	var r0 repository.Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.GetParticipantByGameAndUserParams) (repository.Participant, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.GetParticipantByGameAndUserParams) repository.Participant); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.Participant)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.GetParticipantByGameAndUserParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_GetParticipantByGameAndUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetParticipantByGameAndUser'
type Querier_GetParticipantByGameAndUser_Call struct {
	*mock.Call
}

// GetParticipantByGameAndUser is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.GetParticipantByGameAndUserParams
func (_e *Querier_Expecter) GetParticipantByGameAndUser(ctx interface{}, arg interface{}) *Querier_GetParticipantByGameAndUser_Call {
	return &Querier_GetParticipantByGameAndUser_Call{Call: _e.mock.On("GetParticipantByGameAndUser", ctx, arg)}
}

func (_c *Querier_GetParticipantByGameAndUser_Call) Run(run func(ctx context.Context, arg repository.GetParticipantByGameAndUserParams)) *Querier_GetParticipantByGameAndUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.GetParticipantByGameAndUserParams
		if args[1] != nil {
			arg1 = args[1].(repository.GetParticipantByGameAndUserParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_GetParticipantByGameAndUser_Call) Return(participant repository.Participant, err error) *Querier_GetParticipantByGameAndUser_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *Querier_GetParticipantByGameAndUser_Call) RunAndReturn(run func(ctx context.Context, arg repository.GetParticipantByGameAndUserParams) (repository.Participant, error)) *Querier_GetParticipantByGameAndUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeam provides a mock function for the type Querier
func (_mock *Querier) GetTeam(ctx context.Context, id pgtype.UUID) (repository.Team, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTeam")
	}

	var r0 repository.Team
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) (repository.Team, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) repository.Team); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(repository.Team)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_GetTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeam'
type Querier_GetTeam_Call struct {
	*mock.Call
}

// GetTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) GetTeam(ctx interface{}, id interface{}) *Querier_GetTeam_Call {
	return &Querier_GetTeam_Call{Call: _e.mock.On("GetTeam", ctx, id)}
}

func (_c *Querier_GetTeam_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_GetTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_GetTeam_Call) Return(team repository.Team, err error) *Querier_GetTeam_Call {
	_c.Call.Return(team, err)
	return _c
}

func (_c *Querier_GetTeam_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) (repository.Team, error)) *Querier_GetTeam_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function for the type Querier
func (_mock *Querier) GetUserByEmail(ctx context.Context, email string) (repository.User, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 repository.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (repository.User, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) repository.User); ok {
		r0 = returnFunc(ctx, email)
	} else {
		r0 = ret.Get(0).(repository.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type Querier_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *Querier_Expecter) GetUserByEmail(ctx interface{}, email interface{}) *Querier_GetUserByEmail_Call {
	return &Querier_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email)}
}

func (_c *Querier_GetUserByEmail_Call) Run(run func(ctx context.Context, email string)) *Querier_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_GetUserByEmail_Call) Return(user repository.User, err error) *Querier_GetUserByEmail_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *Querier_GetUserByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (repository.User, error)) *Querier_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByID provides a mock function for the type Querier
func (_mock *Querier) GetUserByID(ctx context.Context, id pgtype.UUID) (repository.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByID")
	}

	var r0 repository.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) (repository.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) repository.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(repository.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_GetUserByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByID'
type Querier_GetUserByID_Call struct {
	*mock.Call
}

// GetUserByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id pgtype.UUID
func (_e *Querier_Expecter) GetUserByID(ctx interface{}, id interface{}) *Querier_GetUserByID_Call {
	return &Querier_GetUserByID_Call{Call: _e.mock.On("GetUserByID", ctx, id)}
}

func (_c *Querier_GetUserByID_Call) Run(run func(ctx context.Context, id pgtype.UUID)) *Querier_GetUserByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_GetUserByID_Call) Return(user repository.User, err error) *Querier_GetUserByID_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *Querier_GetUserByID_Call) RunAndReturn(run func(ctx context.Context, id pgtype.UUID) (repository.User, error)) *Querier_GetUserByID_Call {
	_c.Call.Return(run)
	return _c
}

// ListActiveParticipantsByGame provides a mock function for the type Querier
func (_mock *Querier) ListActiveParticipantsByGame(ctx context.Context, gameID pgtype.UUID) ([]repository.ListActiveParticipantsByGameRow, error) {
	ret := _mock.Called(ctx, gameID)

	if len(ret) == 0 {
		panic("no return value specified for ListActiveParticipantsByGame")
	}

	var r0 []repository.ListActiveParticipantsByGameRow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) ([]repository.ListActiveParticipantsByGameRow, error)); ok {
		return returnFunc(ctx, gameID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) []repository.ListActiveParticipantsByGameRow); ok {
		r0 = returnFunc(ctx, gameID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.ListActiveParticipantsByGameRow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, gameID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_ListActiveParticipantsByGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListActiveParticipantsByGame'
type Querier_ListActiveParticipantsByGame_Call struct {
	*mock.Call
}

// ListActiveParticipantsByGame is a helper method to define mock.On call
//   - ctx context.Context
//   - gameID pgtype.UUID
func (_e *Querier_Expecter) ListActiveParticipantsByGame(ctx interface{}, gameID interface{}) *Querier_ListActiveParticipantsByGame_Call {
	return &Querier_ListActiveParticipantsByGame_Call{Call: _e.mock.On("ListActiveParticipantsByGame", ctx, gameID)}
}

func (_c *Querier_ListActiveParticipantsByGame_Call) Run(run func(ctx context.Context, gameID pgtype.UUID)) *Querier_ListActiveParticipantsByGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_ListActiveParticipantsByGame_Call) Return(listActiveParticipantsByGameRows []repository.ListActiveParticipantsByGameRow, err error) *Querier_ListActiveParticipantsByGame_Call {
	_c.Call.Return(listActiveParticipantsByGameRows, err)
	return _c
}

func (_c *Querier_ListActiveParticipantsByGame_Call) RunAndReturn(run func(ctx context.Context, gameID pgtype.UUID) ([]repository.ListActiveParticipantsByGameRow, error)) *Querier_ListActiveParticipantsByGame_Call {
	_c.Call.Return(run)
	return _c
}

// ListGamesInRadius provides a mock function for the type Querier
func (_mock *Querier) ListGamesInRadius(ctx context.Context, arg repository.ListGamesInRadiusParams) ([]repository.ListGamesInRadiusRow, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for ListGamesInRadius")
	}

	var r0 []repository.ListGamesInRadiusRow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.ListGamesInRadiusParams) ([]repository.ListGamesInRadiusRow, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.ListGamesInRadiusParams) []repository.ListGamesInRadiusRow); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.ListGamesInRadiusRow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.ListGamesInRadiusParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_ListGamesInRadius_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGamesInRadius'
type Querier_ListGamesInRadius_Call struct {
	*mock.Call
}

// ListGamesInRadius is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.ListGamesInRadiusParams
func (_e *Querier_Expecter) ListGamesInRadius(ctx interface{}, arg interface{}) *Querier_ListGamesInRadius_Call {
	return &Querier_ListGamesInRadius_Call{Call: _e.mock.On("ListGamesInRadius", ctx, arg)}
}

func (_c *Querier_ListGamesInRadius_Call) Run(run func(ctx context.Context, arg repository.ListGamesInRadiusParams)) *Querier_ListGamesInRadius_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.ListGamesInRadiusParams
		if args[1] != nil {
			arg1 = args[1].(repository.ListGamesInRadiusParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_ListGamesInRadius_Call) Return(listGamesInRadiusRows []repository.ListGamesInRadiusRow, err error) *Querier_ListGamesInRadius_Call {
	_c.Call.Return(listGamesInRadiusRows, err)
	return _c
}

func (_c *Querier_ListGamesInRadius_Call) RunAndReturn(run func(ctx context.Context, arg repository.ListGamesInRadiusParams) ([]repository.ListGamesInRadiusRow, error)) *Querier_ListGamesInRadius_Call {
	_c.Call.Return(run)
	return _c
}

// ListParticipantsByGame provides a mock function for the type Querier
func (_mock *Querier) ListParticipantsByGame(ctx context.Context, gameID pgtype.UUID) ([]repository.ListParticipantsByGameRow, error) {
	ret := _mock.Called(ctx, gameID)

	if len(ret) == 0 {
		panic("no return value specified for ListParticipantsByGame")
	}

	var r0 []repository.ListParticipantsByGameRow
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) ([]repository.ListParticipantsByGameRow, error)); ok {
		return returnFunc(ctx, gameID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) []repository.ListParticipantsByGameRow); ok {
		r0 = returnFunc(ctx, gameID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.ListParticipantsByGameRow)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, gameID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_ListParticipantsByGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListParticipantsByGame'
type Querier_ListParticipantsByGame_Call struct {
	*mock.Call
}

// ListParticipantsByGame is a helper method to define mock.On call
//   - ctx context.Context
//   - gameID pgtype.UUID
func (_e *Querier_Expecter) ListParticipantsByGame(ctx interface{}, gameID interface{}) *Querier_ListParticipantsByGame_Call {
	return &Querier_ListParticipantsByGame_Call{Call: _e.mock.On("ListParticipantsByGame", ctx, gameID)}
}

func (_c *Querier_ListParticipantsByGame_Call) Run(run func(ctx context.Context, gameID pgtype.UUID)) *Querier_ListParticipantsByGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_ListParticipantsByGame_Call) Return(listParticipantsByGameRows []repository.ListParticipantsByGameRow, err error) *Querier_ListParticipantsByGame_Call {
	_c.Call.Return(listParticipantsByGameRows, err)
	return _c
}

func (_c *Querier_ListParticipantsByGame_Call) RunAndReturn(run func(ctx context.Context, gameID pgtype.UUID) ([]repository.ListParticipantsByGameRow, error)) *Querier_ListParticipantsByGame_Call {
	_c.Call.Return(run)
	return _c
}

// ListParticipantsByUser provides a mock function for the type Querier
func (_mock *Querier) ListParticipantsByUser(ctx context.Context, userID pgtype.UUID) ([]repository.Participant, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for ListParticipantsByUser")
	}

	var r0 []repository.Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) ([]repository.Participant, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) []repository.Participant); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.Participant)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_ListParticipantsByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListParticipantsByUser'
type Querier_ListParticipantsByUser_Call struct {
	*mock.Call
}

// ListParticipantsByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID pgtype.UUID
func (_e *Querier_Expecter) ListParticipantsByUser(ctx interface{}, userID interface{}) *Querier_ListParticipantsByUser_Call {
	return &Querier_ListParticipantsByUser_Call{Call: _e.mock.On("ListParticipantsByUser", ctx, userID)}
}

func (_c *Querier_ListParticipantsByUser_Call) Run(run func(ctx context.Context, userID pgtype.UUID)) *Querier_ListParticipantsByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_ListParticipantsByUser_Call) Return(participants []repository.Participant, err error) *Querier_ListParticipantsByUser_Call {
	_c.Call.Return(participants, err)
	return _c
}

func (_c *Querier_ListParticipantsByUser_Call) RunAndReturn(run func(ctx context.Context, userID pgtype.UUID) ([]repository.Participant, error)) *Querier_ListParticipantsByUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListTeamsByGame provides a mock function for the type Querier
func (_mock *Querier) ListTeamsByGame(ctx context.Context, gameID pgtype.UUID) ([]repository.Team, error) {
	ret := _mock.Called(ctx, gameID)

	if len(ret) == 0 {
		panic("no return value specified for ListTeamsByGame")
	}

	var r0 []repository.Team
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) ([]repository.Team, error)); ok {
		return returnFunc(ctx, gameID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, pgtype.UUID) []repository.Team); ok {
		r0 = returnFunc(ctx, gameID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]repository.Team)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, pgtype.UUID) error); ok {
		r1 = returnFunc(ctx, gameID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_ListTeamsByGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTeamsByGame'
type Querier_ListTeamsByGame_Call struct {
	*mock.Call
}

// ListTeamsByGame is a helper method to define mock.On call
//   - ctx context.Context
//   - gameID pgtype.UUID
func (_e *Querier_Expecter) ListTeamsByGame(ctx interface{}, gameID interface{}) *Querier_ListTeamsByGame_Call {
	return &Querier_ListTeamsByGame_Call{Call: _e.mock.On("ListTeamsByGame", ctx, gameID)}
}

func (_c *Querier_ListTeamsByGame_Call) Run(run func(ctx context.Context, gameID pgtype.UUID)) *Querier_ListTeamsByGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 pgtype.UUID
		if args[1] != nil {
			arg1 = args[1].(pgtype.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_ListTeamsByGame_Call) Return(teams []repository.Team, err error) *Querier_ListTeamsByGame_Call {
	_c.Call.Return(teams, err)
	return _c
}

func (_c *Querier_ListTeamsByGame_Call) RunAndReturn(run func(ctx context.Context, gameID pgtype.UUID) ([]repository.Team, error)) *Querier_ListTeamsByGame_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGame provides a mock function for the type Querier
func (_mock *Querier) UpdateGame(ctx context.Context, arg repository.UpdateGameParams) (pgtype.UUID, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGame")
	}

	var r0 pgtype.UUID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateGameParams) (pgtype.UUID, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateGameParams) pgtype.UUID); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(pgtype.UUID)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.UpdateGameParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_UpdateGame_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGame'
type Querier_UpdateGame_Call struct {
	*mock.Call
}

// UpdateGame is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.UpdateGameParams
func (_e *Querier_Expecter) UpdateGame(ctx interface{}, arg interface{}) *Querier_UpdateGame_Call {
	return &Querier_UpdateGame_Call{Call: _e.mock.On("UpdateGame", ctx, arg)}
}

func (_c *Querier_UpdateGame_Call) Run(run func(ctx context.Context, arg repository.UpdateGameParams)) *Querier_UpdateGame_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.UpdateGameParams
		if args[1] != nil {
			arg1 = args[1].(repository.UpdateGameParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_UpdateGame_Call) Return(uUID pgtype.UUID, err error) *Querier_UpdateGame_Call {
	_c.Call.Return(uUID, err)
	return _c
}

func (_c *Querier_UpdateGame_Call) RunAndReturn(run func(ctx context.Context, arg repository.UpdateGameParams) (pgtype.UUID, error)) *Querier_UpdateGame_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateParticipantPayment provides a mock function for the type Querier
func (_mock *Querier) UpdateParticipantPayment(ctx context.Context, arg repository.UpdateParticipantPaymentParams) (repository.Participant, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateParticipantPayment")
	}

	var r0 repository.Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateParticipantPaymentParams) (repository.Participant, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateParticipantPaymentParams) repository.Participant); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.Participant)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.UpdateParticipantPaymentParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_UpdateParticipantPayment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateParticipantPayment'
type Querier_UpdateParticipantPayment_Call struct {
	*mock.Call
}

// UpdateParticipantPayment is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.UpdateParticipantPaymentParams
func (_e *Querier_Expecter) UpdateParticipantPayment(ctx interface{}, arg interface{}) *Querier_UpdateParticipantPayment_Call {
	return &Querier_UpdateParticipantPayment_Call{Call: _e.mock.On("UpdateParticipantPayment", ctx, arg)}
}

func (_c *Querier_UpdateParticipantPayment_Call) Run(run func(ctx context.Context, arg repository.UpdateParticipantPaymentParams)) *Querier_UpdateParticipantPayment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.UpdateParticipantPaymentParams
		if args[1] != nil {
			arg1 = args[1].(repository.UpdateParticipantPaymentParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_UpdateParticipantPayment_Call) Return(participant repository.Participant, err error) *Querier_UpdateParticipantPayment_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *Querier_UpdateParticipantPayment_Call) RunAndReturn(run func(ctx context.Context, arg repository.UpdateParticipantPaymentParams) (repository.Participant, error)) *Querier_UpdateParticipantPayment_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateParticipantStatus provides a mock function for the type Querier
func (_mock *Querier) UpdateParticipantStatus(ctx context.Context, arg repository.UpdateParticipantStatusParams) (repository.Participant, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateParticipantStatus")
	}

	var r0 repository.Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateParticipantStatusParams) (repository.Participant, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateParticipantStatusParams) repository.Participant); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.Participant)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.UpdateParticipantStatusParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_UpdateParticipantStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateParticipantStatus'
type Querier_UpdateParticipantStatus_Call struct {
	*mock.Call
}

// UpdateParticipantStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.UpdateParticipantStatusParams
func (_e *Querier_Expecter) UpdateParticipantStatus(ctx interface{}, arg interface{}) *Querier_UpdateParticipantStatus_Call {
	return &Querier_UpdateParticipantStatus_Call{Call: _e.mock.On("UpdateParticipantStatus", ctx, arg)}
}

func (_c *Querier_UpdateParticipantStatus_Call) Run(run func(ctx context.Context, arg repository.UpdateParticipantStatusParams)) *Querier_UpdateParticipantStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.UpdateParticipantStatusParams
		if args[1] != nil {
			arg1 = args[1].(repository.UpdateParticipantStatusParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_UpdateParticipantStatus_Call) Return(participant repository.Participant, err error) *Querier_UpdateParticipantStatus_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *Querier_UpdateParticipantStatus_Call) RunAndReturn(run func(ctx context.Context, arg repository.UpdateParticipantStatusParams) (repository.Participant, error)) *Querier_UpdateParticipantStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateParticipantStatusResetJoinedAt provides a mock function for the type Querier
func (_mock *Querier) UpdateParticipantStatusResetJoinedAt(ctx context.Context, arg repository.UpdateParticipantStatusResetJoinedAtParams) (repository.Participant, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateParticipantStatusResetJoinedAt")
	}

	var r0 repository.Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateParticipantStatusResetJoinedAtParams) (repository.Participant, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateParticipantStatusResetJoinedAtParams) repository.Participant); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.Participant)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.UpdateParticipantStatusResetJoinedAtParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_UpdateParticipantStatusResetJoinedAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateParticipantStatusResetJoinedAt'
type Querier_UpdateParticipantStatusResetJoinedAt_Call struct {
	*mock.Call
}

// UpdateParticipantStatusResetJoinedAt is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.UpdateParticipantStatusResetJoinedAtParams
func (_e *Querier_Expecter) UpdateParticipantStatusResetJoinedAt(ctx interface{}, arg interface{}) *Querier_UpdateParticipantStatusResetJoinedAt_Call {
	return &Querier_UpdateParticipantStatusResetJoinedAt_Call{Call: _e.mock.On("UpdateParticipantStatusResetJoinedAt", ctx, arg)}
}

func (_c *Querier_UpdateParticipantStatusResetJoinedAt_Call) Run(run func(ctx context.Context, arg repository.UpdateParticipantStatusResetJoinedAtParams)) *Querier_UpdateParticipantStatusResetJoinedAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.UpdateParticipantStatusResetJoinedAtParams
		if args[1] != nil {
			arg1 = args[1].(repository.UpdateParticipantStatusResetJoinedAtParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_UpdateParticipantStatusResetJoinedAt_Call) Return(participant repository.Participant, err error) *Querier_UpdateParticipantStatusResetJoinedAt_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *Querier_UpdateParticipantStatusResetJoinedAt_Call) RunAndReturn(run func(ctx context.Context, arg repository.UpdateParticipantStatusResetJoinedAtParams) (repository.Participant, error)) *Querier_UpdateParticipantStatusResetJoinedAt_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateParticipantTeam provides a mock function for the type Querier
func (_mock *Querier) UpdateParticipantTeam(ctx context.Context, arg repository.UpdateParticipantTeamParams) (repository.Participant, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateParticipantTeam")
	}

	var r0 repository.Participant
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateParticipantTeamParams) (repository.Participant, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateParticipantTeamParams) repository.Participant); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.Participant)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.UpdateParticipantTeamParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_UpdateParticipantTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateParticipantTeam'
type Querier_UpdateParticipantTeam_Call struct {
	*mock.Call
}

// UpdateParticipantTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.UpdateParticipantTeamParams
func (_e *Querier_Expecter) UpdateParticipantTeam(ctx interface{}, arg interface{}) *Querier_UpdateParticipantTeam_Call {
	return &Querier_UpdateParticipantTeam_Call{Call: _e.mock.On("UpdateParticipantTeam", ctx, arg)}
}

func (_c *Querier_UpdateParticipantTeam_Call) Run(run func(ctx context.Context, arg repository.UpdateParticipantTeamParams)) *Querier_UpdateParticipantTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.UpdateParticipantTeamParams
		if args[1] != nil {
			arg1 = args[1].(repository.UpdateParticipantTeamParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_UpdateParticipantTeam_Call) Return(participant repository.Participant, err error) *Querier_UpdateParticipantTeam_Call {
	_c.Call.Return(participant, err)
	return _c
}

func (_c *Querier_UpdateParticipantTeam_Call) RunAndReturn(run func(ctx context.Context, arg repository.UpdateParticipantTeamParams) (repository.Participant, error)) *Querier_UpdateParticipantTeam_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function for the type Querier
func (_mock *Querier) UpdateUser(ctx context.Context, arg repository.UpdateUserParams) (repository.User, error) {
	ret := _mock.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 repository.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateUserParams) (repository.User, error)); ok {
		return returnFunc(ctx, arg)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.UpdateUserParams) repository.User); ok {
		r0 = returnFunc(ctx, arg)
	} else {
		r0 = ret.Get(0).(repository.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.UpdateUserParams) error); ok {
		r1 = returnFunc(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// Querier_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type Querier_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - arg repository.UpdateUserParams
func (_e *Querier_Expecter) UpdateUser(ctx interface{}, arg interface{}) *Querier_UpdateUser_Call {
	return &Querier_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, arg)}
}

func (_c *Querier_UpdateUser_Call) Run(run func(ctx context.Context, arg repository.UpdateUserParams)) *Querier_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.UpdateUserParams
		if args[1] != nil {
			arg1 = args[1].(repository.UpdateUserParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *Querier_UpdateUser_Call) Return(user repository.User, err error) *Querier_UpdateUser_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *Querier_UpdateUser_Call) RunAndReturn(run func(ctx context.Context, arg repository.UpdateUserParams) (repository.User, error)) *Querier_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}
